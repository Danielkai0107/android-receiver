# ✅ 等待上傳整合機制 + 參數設定完成

## 🎯 實施內容

1. ✅ **等待上傳記錄智能整合** - 相同 Beacon 只保留信號最強的
2. ✅ **參數設定頁面** - 所有參數都可以編輯

---

## 📋 Part 1: 等待上傳整合機制

### 問題分析

**原來的問題**:
```
beacon_queue 表 (uploadStatus = PENDING):
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
UUID: FDA50693... | Major: 1 | Minor: 1001 | RSSI: -65
UUID: FDA50693... | Major: 1 | Minor: 1001 | RSSI: -70  ← 相同 Beacon
UUID: FDA50693... | Major: 1 | Minor: 1001 | RSSI: -68  ← 相同 Beacon
UUID: FDA50693... | Major: 1 | Minor: 1001 | RSSI: -72  ← 相同 Beacon
... (10 條相同的 Beacon，不同 RSSI)

結果：
⏳ 待上傳: 10        ← 實際只有 1 個不同的 Beacon
上傳時會上傳 10 條  ← 浪費資源
```

### 解決方案

#### 方案 1: 插入時智能比較（實時整合）

```kotlin
suspend fun addToQueue(beacon: Beacon): Result<Long> {
    // 檢查是否已有相同的 PENDING 記錄
    val existingBeacon = beaconQueueDao.getPendingBeacon(uuid, major, minor)
    
    if (existingBeacon != null) {
        // 比較信號強度
        if (beacon.rssi > existingBeacon.rssi) {
            // 新記錄信號更強 → 刪除舊記錄，插入新記錄
            beaconQueueDao.deleteOldPending(uuid, major, minor)
            Log.d(TAG, "更新 Beacon（信號更強）: 舊 RSSI=${existingBeacon.rssi} → 新 RSSI=${beacon.rssi}")
        } else {
            // 舊記錄信號更強 → 保留舊記錄，不插入
            Log.d(TAG, "保留舊記錄（信號更強）: 舊 RSSI=${existingBeacon.rssi} ≥ 新 RSSI=${beacon.rssi}")
            return Result.success(existingBeacon.id)
        }
    }
    
    // 插入新記錄
    beaconQueueDao.insert(entity)
}
```

#### 方案 2: 上傳前批次整合（雙重保護）

```kotlin
private suspend fun performUpload() {
    // 上傳前先整合相同的 Beacon，只保留信號最強的
    beaconRepository.consolidatePendingBeacons()
    
    val pendingBeacons = beaconRepository.getPendingBeacons()
    // 現在 pendingBeacons 中每個 Beacon 只有一條記錄（信號最強的）
}
```

**SQL 整合邏輯**:
```sql
DELETE FROM beacon_queue 
WHERE uploadStatus = 'PENDING'
AND id NOT IN (
    -- 只保留每個 UUID+Major+Minor 組合中 RSSI 最大的記錄
    SELECT id FROM beacon_queue 
    WHERE uploadStatus = 'PENDING'
    AND (uuid, major, minor, rssi) IN (
        SELECT uuid, major, minor, MAX(rssi)
        FROM beacon_queue 
        WHERE uploadStatus = 'PENDING'
        GROUP BY uuid, major, minor
    )
)
```

---

### 整合效果

**修復前**:
```
掃描 60 秒，同一個 Beacon 掃描到 20 次：
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
⏳ 待上傳: 20        ← 20 條記錄
上傳時發送 20 條     ← 浪費
Firebase 收到 20 次更新  ← 冗餘
```

**修復後**:
```
掃描 60 秒，同一個 Beacon 掃描到 20 次：
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
⏳ 待上傳: 1         ← 只保留信號最強的那條
上傳時發送 1 條      ← 高效
Firebase 收到 1 次更新   ← 精準
```

---

## 📋 Part 2: 參數設定頁面

### 可編輯的參數

| 參數名稱 | 預設值 | 可選值 | 說明 |
|---------|--------|--------|------|
| 掃描頻率 | 5 秒 | 3, 5, 7, 10 秒 | Beacon 掃描間隔時間 |
| 上傳間隔 | 60 秒 | 30, 60, 90, 120 秒 | 批次上傳的時間間隔 |
| GPS 更新頻率 | 2 分鐘 | 1, 2, 3, 5 分鐘 | 位置更新的時間間隔 |
| 離線快取上限 | 1000 筆 | 500, 1000, 1500, 2000 筆 | 最多保存的離線記錄數 |

**白名單同步間隔**: 已隱藏（改為啟動時自動同步 UUID）

---

### 設定頁面 UI

```
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
⚙️ 參數設定
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━

┌────────────────────────────────────┐
│ 掃描頻率                      5 秒  │ ← 可點擊
│ Beacon 掃描間隔時間                │
└────────────────────────────────────┘

┌────────────────────────────────────┐
│ 上傳間隔                     60 秒  │ ← 可點擊
│ 批次上傳的時間間隔                 │
└────────────────────────────────────┘

┌────────────────────────────────────┐
│ GPS 更新頻率                2 分鐘  │ ← 可點擊
│ 位置更新的時間間隔                 │
└────────────────────────────────────┘

┌────────────────────────────────────┐
│ 離線快取上限               1000 筆  │ ← 可點擊
│ 最多保存的離線記錄數               │
└────────────────────────────────────┘
```

---

### 編輯方式

點擊任一項目會彈出選擇對話框：

**範例：上傳間隔**
```
┌─────────────────────┐
│   上傳間隔          │
├─────────────────────┤
│ ○ 30 秒            │
│ ● 60 秒（預設）    │ ← 當前選擇
│ ○ 90 秒            │
│ ○ 120 秒           │
└─────────────────────┘
```

選擇後：
- Toast: "已設定為 90 秒"
- 立即保存到 DataStore
- 下次上傳使用新設定

---

## 🔧 修改內容

### 1️⃣ BeaconQueueDao.kt
```kotlin
// 新增：查詢同一個 Beacon 的 PENDING 記錄
@Query("SELECT * FROM beacon_queue WHERE uuid = :uuid AND major = :major AND minor = :minor AND uploadStatus = 'PENDING' LIMIT 1")
suspend fun getPendingBeacon(uuid: String, major: Int, minor: Int): BeaconQueueEntity?

// 新增：整合相同的 PENDING 記錄，只保留信號最強的
@Query("""
    DELETE FROM beacon_queue 
    WHERE uploadStatus = 'PENDING'
    AND id NOT IN (
        SELECT id FROM beacon_queue 
        WHERE uploadStatus = 'PENDING'
        AND (uuid, major, minor, rssi) IN (
            SELECT uuid, major, minor, MAX(rssi)
            FROM beacon_queue 
            WHERE uploadStatus = 'PENDING'
            GROUP BY uuid, major, minor
        )
    )
""")
suspend fun consolidatePendingBeacons()

// 修改：統計不同的 Beacon 數量（去重）
@Query("""
    SELECT COUNT(DISTINCT uuid || '-' || major || '-' || minor) 
    FROM beacon_queue 
    WHERE uploadStatus = 'PENDING'
""")
fun getPendingCountFlow(): Flow<Int>
```

### 2️⃣ BeaconRepository.kt
```kotlin
// 修改：插入時智能比較信號強度
suspend fun addToQueue(beacon: Beacon): Result<Long> {
    // 檢查是否已有同一個 Beacon 的 PENDING 記錄
    val existingBeacon = beaconQueueDao.getPendingBeacon(uuid, major, minor)
    
    if (existingBeacon != null) {
        if (beacon.rssi > existingBeacon.rssi) {
            // 新記錄信號更強，更新
            beaconQueueDao.deleteOldPending(uuid, major, minor)
        } else {
            // 舊記錄信號更強，保留
            return Result.success(existingBeacon.id)
        }
    }
    
    // 插入新記錄
    beaconQueueDao.insert(entity)
}

// 新增：整合方法
suspend fun consolidatePendingBeacons() {
    beaconQueueDao.consolidatePendingBeacons()
}
```

### 3️⃣ BeaconScanService.kt
```kotlin
private suspend fun performUpload() {
    // 上傳前先整合
    beaconRepository.consolidatePendingBeacons()
    
    val pendingBeacons = beaconRepository.getPendingBeacons()
    Log.d(TAG, "準備上傳 ${pendingBeacons.size} 個不同的 Beacon")
    ...
}
```

### 4️⃣ UploadWorker.kt
```kotlin
override suspend fun doWork(): Result {
    // 上傳前先整合
    beaconRepository.consolidatePendingBeacons()
    
    val pendingBeacons = beaconRepository.getPendingBeacons()
    ...
}
```

### 5️⃣ fragment_settings.xml
```xml
<!-- 隱藏白名單同步間隔（已改為啟動時自動同步） -->
android:visibility="gone"
```

---

## 🎯 整合邏輯說明

### 實時整合（插入時）

```
掃描到 Beacon A (RSSI: -65)
  ↓
檢查 beacon_queue 是否已有 Beacon A 的 PENDING 記錄？
  ├─ ❌ 沒有 → 直接插入
  └─ ✅ 有（舊 RSSI: -70）
       ↓
     比較信號強度：-65 > -70 ?
       ├─ ✅ 是 → 刪除舊記錄，插入新記錄
       └─ ❌ 否 → 保留舊記錄，不插入
```

### 批次整合（上傳前）

```
準備上傳
  ↓
執行 consolidatePendingBeacons()
  ↓
刪除所有不是「最強信號」的 PENDING 記錄
  ↓
結果：每個 Beacon (UUID+Major+Minor) 只有一條記錄
  ↓
開始上傳
```

---

## 📊 效果對比

### 場景：掃描 60 秒

**修復前**:
```
掃描到 3 個不同的 Beacon，每個掃描到 20 次：
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
beacon_queue 記錄數: 60 條
⏳ 待上傳: 60
上傳時發送: 60 條記錄
Firebase 更新: 60 次（大量冗餘）
```

**修復後**:
```
掃描到 3 個不同的 Beacon，每個掃描到 20 次：
━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━
beacon_queue 記錄數: 3 條（每個只保留信號最強的）
⏳ 待上傳: 3
上傳時發送: 3 條記錄
Firebase 更新: 3 次（精準高效）
```

---

## 📋 Part 2: 參數設定頁面

### 可編輯參數

#### 1. 掃描頻率
- **預設**: 5 秒
- **選項**: 3, 5, 7, 10 秒
- **影響**: Beacon 掃描間隔
- **建議**: 5 秒（平衡效能和電量）

#### 2. 上傳間隔
- **預設**: 60 秒
- **選項**: 30, 60, 90, 120 秒
- **影響**: 多久上傳一次到 Firebase
- **建議**: 60 秒（平衡即時性和網絡使用）

#### 3. GPS 更新頻率
- **預設**: 2 分鐘
- **選項**: 1, 2, 3, 5 分鐘
- **影響**: 位置更新頻率
- **建議**: 2 分鐘（平衡精準度和電量）

#### 4. 離線快取上限
- **預設**: 1000 筆
- **選項**: 500, 1000, 1500, 2000 筆
- **影響**: 最多保存多少離線記錄
- **建議**: 1000 筆（足夠應對短期離線）

---

## 🎨 使用方式

### 進入設定頁面
```
底部導覽 → 點擊「設定」圖標
```

### 修改參數
```
1. 點擊任一參數項目
2. 彈出選擇對話框
3. 選擇新值
4. Toast 提示「已設定為 XX」
5. 立即生效
```

### 參數保存
- ✅ 使用 DataStore 持久化保存
- ✅ App 重啟後保留設定
- ✅ 立即生效，無需重啟服務

---

## 🔍 Logcat 監控

### 整合機制
```bash
adb logcat | grep "BeaconRepository"
```

**預期輸出**:
```
D/BeaconRepository: Beacon 加入佇列: uuid=FDA50693..., major=1, minor=1001, rssi=-65
D/BeaconRepository: 保留舊記錄（信號更強）: 舊 RSSI=-65 ≥ 新 RSSI=-70
D/BeaconRepository: 更新 Beacon（信號更強）: 舊 RSSI=-70 → 新 RSSI=-65
```

### 上傳前整合
```bash
adb logcat | grep "BeaconScanService.*上傳"
```

**預期輸出**:
```
D/BeaconScanService: 準備上傳 3 個不同的 Beacon
D/BeaconScanService: ✅ 上傳成功: 3 筆，已更新狀態為 UPLOADED
```

---

## 📦 構建結果

✅ **構建成功！**

**APK 位置**:
```
/Users/danielkai/Desktop/android-receiver/app/build/outputs/apk/debug/app-debug.apk
```

---

## 🧪 測試步驟

### 1. 安裝新版本
```bash
adb install app-debug.apk
```

### 2. 測試整合機制

**步驟**:
1. 開始掃描
2. 等待 30 秒（不要上傳）
3. 觀察「⏳ 待上傳」數字
4. 應該看到數字增長緩慢（因為相同 Beacon 只保留一條）

**Logcat**:
```bash
adb logcat | grep "BeaconRepository"
```

應該看到：
```
D/BeaconRepository: Beacon 加入佇列: uuid=FDA50693..., rssi=-65
D/BeaconRepository: 保留舊記錄（信號更強）: 舊 RSSI=-65 ≥ 新 RSSI=-68
```

### 3. 測試參數設定

**步驟**:
1. 切換到「設定」分頁
2. 點擊「上傳間隔」
3. 選擇「30 秒」
4. Toast 顯示「已設定為 30 秒」
5. 觀察上傳間隔是否變為 30 秒

---

## ✅ 驗證清單

### 整合機制
- [ ] 相同 Beacon 只保留一條 PENDING 記錄
- [ ] 保留的是信號最強的
- [ ] 「待上傳」數字合理（不會暴增）
- [ ] 上傳時日誌顯示「準備上傳 X 個不同的 Beacon」

### 參數設定
- [ ] 可以進入設定頁面
- [ ] 所有參數都可以點擊
- [ ] 選擇對話框正常彈出
- [ ] 修改後立即生效
- [ ] Toast 提示正確

---

## 🎯 關鍵優勢

### 整合機制
✅ 減少冗餘數據  
✅ 降低網絡流量  
✅ 減少 Firebase 寫入  
✅ 提升上傳效率  
✅ 保留最佳信號  

### 參數設定
✅ 所有參數可調整  
✅ 立即生效  
✅ 持久化保存  
✅ 用戶友好界面  
✅ 適應不同使用場景  

---

## 🎉 完成

**等待上傳整合機制 + 參數設定功能完成！** 🚀

### 修改檔案
1. ✅ BeaconQueueDao.kt - 添加整合和查詢方法
2. ✅ BeaconRepository.kt - 智能比較和整合
3. ✅ BeaconScanService.kt - 上傳前整合
4. ✅ UploadWorker.kt - 上傳前整合
5. ✅ fragment_settings.xml - 隱藏白名單同步

### 現有功能
- ✅ SettingsFragment.kt - 已實現編輯功能
- ✅ SettingsViewModel.kt - 已實現保存邏輯
- ✅ PreferenceManager.kt - 已實現持久化

**安裝測試新版本！** 🚀